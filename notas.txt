10-5 no jala
pero 10 - 5 si (o 10- 5)

solo tenemos 1 tabla de funciones locales
hay que hacer que cada clase y función tenga la suya

t0...tn, sí lo dejamos así?
sí está bien solo ponerle dir virtual ponerlas en la tabla de variables actual, ya sea func o global

num1 = func2(5, 10, "hola"); no jala. var = llamada *ya*
YA POR FIN ENCONTRE EL ERROR checa doble ';' jajaj sufrí

con el 'era' ya sabe en qué cuádruplo inicia la función?
gosub para cuadruplo de inicio

con 'endfunc' ya sabe a donde volver?
lo hace en la máquina virtual

hay que guardar las constantes en una tabla y ponerles dirección

hacer validaciones de variables y funciones duplicadas en el insert de la tabla y no en parser.py *ya*

checar tipo y cantidad de parametros *ya*
eliminar de pila de tipos lo del for y declaracion *ya*

guardar nombre de función en vars globales si no regresa void *ya*
nada mas que hay conflicto con objetos porque se guardan en la misma tabla. una llamada puede ser func(); y diria que es un objeto por estar en la tabla de variables globales

cuadruplos de return (y validar que devuelva el mismo tipo que la función)*ya*

return func(x-1) no se puede

probar que pasa cuando no hay alguna tabla (como de constantes) *ya*

dirVir float no pone temporales. no escribe 16001. *ya*

se repiten las constantes globales cuando las vuelves a usar. por ejemplo 20001: 2, 20002: 2 *asi se quedan*

arreglos como en c++ no son inclusive (tmb el for)
a[5] --> a[0], a[1], a[2], a[3], a[4]

asigna al reves
num3 = func3(2, 10, "hola");

imprimir arreglo sin indice devuelve el primero

arreglos dentro de funciones y clases crean constantes globales

no guardar strings constantes con coma

en maquina virtual, qué se hace con el cuadruplo de return?

checar objetos en param de funciones

si pones un arreglo en una funcion se hacen mal en main

cuando es recursivo es una llamada menos

pone objeto como int en clase en tablavarsclase, nvm las constantes tmb son variables

las func void necesitan un return

creo que jala funciones